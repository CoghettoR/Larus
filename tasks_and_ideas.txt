TODO:

*******************************************************************************************************************

IDEAS:

1. Julien: Here are some ideas of potential additional constraints to reduce the search space:
- all axioms should be used in the proof
- the same fact should not be derived twice in the same branch  (proof step ( the fact deduced) can not appear twice.)

2. Julien: I noticed that we can optimize the encoding:
the formula of the form A & B & C & D are encoded using
P -> A
P -> B
P -> C
P -> D
When there is no assumption I think we can just split the facts:
A
B
C
D.

3. Julien: The readable proof we have a cut-free (we do not introduce lemma),  
I wondering if we can really generate readable proof which provide explaination 
without introducing lemmas.

4. Julien: It seems that for some problems the function which maps n to the time to 
find a proof or fail to find a proof of n is not increasing in n!  
larger value of n can sometimes give much smaller computing time.
On our several cores computer 
we could run in parallel size 8, 16, 32 and take the first answer ? or 
another solution is to give this problem to the solver.

5 Julien: to deal with symmetry we can make an experiment by imposing the order of the point in 
Col predicates, deriving Col X Y Z we can add a constraint that X <= Y <= Z.

6. Julien: Idea for tree traversal for annotating Nesting

7. Julien: I just realized that the example non_nested_case_split produces proofs only with 
nested case split. It is not a bug, it is just that CL does not allow "subproofs". 
I would have expected the following proof (not the step with just an assert). It is just a 
thought. I am not sure we should implement that.

Theorem nonnestedcasesplit : forall Z : MyT, r Z -> g1 Z /\ g2 Z.
Proof.
intros ca.
intros.
assert(g1 ca).
 {
  assert (p ca \/ q ca) by applying (ax1 ca).
  by cases on (p ca \/ q ca).
  - assert (g1 ca) by applying (ax2 ca).
    conclude.
  - assert (g1 ca) by applying (ax3 ca).
    conclude.
}
assert(g2 ca).
 {
  assert (p2 ca \/ q2 ca) by applying (ax4 ca).
  by cases on (p2 ca \/ q2 ca).
  - assert (g2 ca) by applying (ax5 ca).
   conclude.
  - assert (g2 ca) by applying (ax6 ca).
   conclude.
}
conclude.
Qed.

8. Julien: Maybe we could implement something similar to RETE algorithm in the encoding:
 if two rules share some assumptions, we could share some part of the matching ?

9. Predrag: Namely, there are some theorems proved
    easily by stl and not by ursa and vice versa. Why?
    For instance, if there is an axiom "dom(a) & dom(b)", the stl
    engine will quickly apply it, while the ursa engine would consider
    all possible axioms for all possible proof steps. Thanks to this,
    stl proves some theorems, and ursa does not. We have to exploit these things. 

10. Julien:
 Let's assume that we have natural language proof in latex and we want to turn it into a formal proof. The structure of such a proof is hard to  reconstruct automatically, it is hard to formalize each sentence in the proof. But it may help our prover to detect just a few things in the proofs and to try to reconstruct the proof using these pieces of information.
 Maybe we could help the CLprover/SAT/SMT by saying that some proof steps is using (perp_bisect_cong2 G A' B C)
 but we do not have to provide the precise information that it is in a subgoal to prove Cong B C C G.
 So the approach would be a little bit different than just cutting the natural proof in small pieces in order to try to get a formal proof. Here we would help the system  by giving some information. I think it would be closer to what a human does when he formalizes a natural language proof: you have hints that you should use some proofs steps. But usually the natural language proof forgets some special cases. So if you try to prove automatically that one step can be derived from the previous it will fail because sometimes some assumptions are missing. For example, in Euclid proof, often only the proof in the general case is given.

13. Predrag: We can try to use incolmplete SAT solvers for SAT solving:
https://github.com/msoos/walksat
 Walksat cannot find a model for one conjecture (nested2)

14. Julien: use some others SAT solvers: I tried walksat on the two examples and I could not get a model.
On the nested2b-42s (of course we can not compare to 42s):
Using glucose : 12s
Using cryptominisat: 9s.
cadical: 20s

15: Julien: We could add a constraint to never put 'case foo' inside 'case foo'.
    Predrag: Would be useful only for a very few conjectures, on the other hand would complicate encoding.

16. Julien: try incremental building of constraints (a descrption of the proof step n+1 uses a description of the proof step n)
    Predrag tried, with no success.

17. There could be some CL proof normalization procedure that could simplify the encoding and the search.


